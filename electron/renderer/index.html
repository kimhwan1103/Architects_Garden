<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Local Notes — Main</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- 스타일 -->
  <style>
    :root{ --bg:#fafafa; --line:#e5e5e5; --left:280px; --right:360px; }
    *{ box-sizing:border-box } html,body{ height:100%; margin:0; }
    body{ font-family:system-ui, Segoe UI, Apple SD Gothic Neo, Malgun Gothic, sans-serif; background:var(--bg); }
    .layout{ display:grid; grid-template-columns: var(--left) 1fr var(--right); gap:10px; height:100vh; padding:10px; }
    .panel{ background:#fff; border:1px solid var(--line); border-radius:12px; padding:12px; overflow:auto; }
    .split-col{ display:flex; flex-direction:column; gap:10px; height:100% }
    .list{ display:flex; flex-direction:column; gap:6px; }
    .note-item{ padding:8px; border:1px solid transparent; border-radius:8px; cursor:pointer; }
    .note-item:hover{ background:#f7f7f7; } .note-item.active{ background:#eef2ff; border-color:#c7d2fe; }
    .muted{ color:#666; font-size:12px }
    .tag{ background:#efefef; border-radius:999px; padding:2px 8px; font-size:12px; margin-right:6px }
    input[type=text]{ width:100%; padding:10px; border:1px solid var(--line); border-radius:8px; }
    .row{ display:flex; gap:8px; align-items:center }
    .btn{ padding:8px 10px; border:1px solid var(--line); border-radius:8px; background:#f5f5f5; cursor:pointer }
    .primary{ background:#111; color:#fff; border-color:#111 }
    .editor{ display:flex; flex-direction:column; gap:10px; height:100% }
    /* Toast UI Editor 높이 보정 */
    #mdEditor{ flex:1; min-height:420px; }
    .toastui-editor-defaultUI{ height:100%; }
    .toastui-editor-main{ height:calc(100% - 44px); } /* toolbar 제외 */
    .toastui-editor-contents{ font-size:15px; line-height:1.6; }
  </style>

  <!-- Toast UI Editor (CDN) -->
  <link rel="stylesheet" href="https://uicdn.toast.com/editor/latest/toastui-editor.min.css" />
  <script src="https://uicdn.toast.com/editor/latest/toastui-editor-all.min.js"></script>
</head>
<body>
  <div class="layout">
    <!-- 왼쪽: 노트 리스트 -->
    <aside class="panel split-col">
      <div>
        <h2 style="margin:0 0 8px 0;">노트</h2>
        <div class="row">
          <input id="q" type="text" placeholder="검색 (제목/본문)" />
          <button class="btn" id="searchBtn">검색</button>
        </div>
        <div class="row" style="margin-top:8px;">
          <button class="btn primary" id="newBtn">새 노트</button>
          <button class="btn" id="delBtn">삭제</button>
        </div>
      </div>
      <div class="list" id="noteList"></div>
    </aside>

    <!-- 가운데: 편집기(동일 창에서 라이브 렌더) -->
    <main class="panel editor">
      <div class="row" style="gap:6px;">
        <input id="title" type="text" placeholder="제목" style="flex:1;" />
        <button class="btn primary" id="saveBtn">저장</button>
      </div>
      <input id="tags" type="text" placeholder="태그: 쉼표로 구분" />
      <!-- WYSIWYG 마크다운 에디터 -->
      <div id="mdEditor"></div>
      <div class="muted" id="status">대기 중</div>
    </main>

    <!-- 오른쪽: 어시스턴트 -->
    <aside class="panel">
      <h2 style="margin:0 0 8px 0;">어시스턴트</h2>
      <div id="chatLog" style="border:1px solid var(--line); border-radius:8px; padding:8px; height:70%; overflow:auto"></div>
      <div class="row" style="margin-top:8px;">
        <input id="chatInput" type="text" placeholder="질문을 입력하세요…" style="flex:1;" />
        <button class="btn primary" id="sendBtn">보내기</button>
        <button class="btn" id="clearChat">지우기</button>
      </div>
    </aside>
  </div>

  <!-- ===== 스크립트 ===== -->
  <script>
    const API = "http://127.0.0.1:8421/api";
    const $ = s => document.querySelector(s);

    // DOM
    const noteListEl = $("#noteList");
    const qEl = $("#q"), searchBtn = $("#searchBtn");
    const newBtn = $("#newBtn"), delBtn = $("#delBtn");
    const titleEl = $("#title"), tagsEl = $("#tags"), saveBtn = $("#saveBtn"), statusEl = $("#status");
    const chatLogEl = $("#chatLog"), chatInputEl = $("#chatInput"),
          sendBtn = $("#sendBtn"), clearChatBtn = $("#clearChat");

    // 상태
    let currentId = null;
    let notes = [];
    let chatHistory = [];
    let editor = null; // Toast UI Editor 인스턴스

    const escapeHtml = s => (s ?? "").replace(/[&<>"']/g, m => ({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"}[m]));
    const debounce = (fn, ms=500) => { let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; };

    // ===== 에디터 =====
    function initEditor() {
      editor = new toastui.Editor({
        el: document.querySelector('#mdEditor'),
        height: '100%',
        initialEditType: 'markdown',     // 같은 창에서 즉시 렌더
        previewStyle: 'tab',             // 미리보기 탭 비활성 느낌 (WYSIWYG라 필요 없음)
        usageStatistics: false,
        placeholder: '여기에 마크다운을 입력하세요…',
        toolbarItems: [
          ['heading','bold','italic','strike'],
          ['hr','quote'],
          ['ul','ol','task'],
          ['table','link','image','code','codeblock'],
        ]
      });
      editor.on('change', () => { statusEl.textContent = '편집 중…'; autoSave(); });
    }
    function getContent(){ return editor ? editor.getMarkdown() : ''; }
    function setContent(v){ if (editor) editor.setMarkdown(v || ''); }

    // ===== 리스트 =====
    function renderList() {
      noteListEl.innerHTML = "";
      if (!Array.isArray(notes) || notes.length === 0) {
        noteListEl.innerHTML = `<div class="muted">노트가 없습니다.</div>`;
        return;
      }
      for (const n of notes) {
        const div = document.createElement("div");
        div.className = "note-item" + (n.id === currentId ? " active" : "");
        const when = new Date(n.updated_at).toLocaleString();
        div.innerHTML = `
          <div><strong>${escapeHtml(n.title)}</strong></div>
          <div class="muted" style="font-size:12px">${when}</div>
          <div>${(n.tags||[]).slice(0,3).map(t=>`<span class="tag">${escapeHtml(t)}</span>`).join("")}</div>`;
        div.onclick = () => loadNote(n.id);
        noteListEl.appendChild(div);
      }
    }
    async function fetchList() {
      const url = qEl.value.trim() ? `${API}/notes?query=${encodeURIComponent(qEl.value)}` : `${API}/notes`;
      const res = await fetch(url);
      if (!res.ok) { console.error('GET /api/notes 실패', res.status); return; }
      notes = await res.json(); renderList();
    }

    // ===== 편집/로드/저장 =====
    function setEditor(n) {
      currentId = n?.id || null;
      titleEl.value = n?.title || "";
      tagsEl.value = (n?.tags || []).join(", ");
      setContent(n?.content || "");
      statusEl.textContent = currentId ? `편집 중: ${currentId}` : "새 노트 작성";
      renderList();
    }
    async function loadNote(id) {
      const res = await fetch(`${API}/notes/${id}`);
      if (!res.ok) return;
      setEditor(await res.json());
    }
    async function createNote() {
      const res = await fetch(`${API}/notes`, {
        method:"POST", headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ title:"새 노트", content:"", tags:[] })
      });
      if (!res.ok) return;
      const n = await res.json();
      await fetchList(); await loadNote(n.id);
    }
    async function saveNote() {
      const body = {
        title: titleEl.value.trim(),
        content: getContent(), // 마크다운으로 저장
        tags: tagsEl.value.split(",").map(s=>s.trim()).filter(Boolean)
      };
      if (!body.title) { statusEl.textContent = "제목을 입력해주세요."; return; }
      let res;
      if (!currentId) {
        res = await fetch(`${API}/notes`, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(body) });
        if (!res.ok) return;
        currentId = (await res.json()).id;
        statusEl.textContent = "새 노트 저장 완료";
      } else {
        res = await fetch(`${API}/notes/${currentId}`, { method:"PUT", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(body) });
        if (!res.ok) return;
        statusEl.textContent = "저장 완료";
      }
      await fetchList();
    }
    const autoSave = debounce(async ()=>{
      // 제목/내용이 비어있지 않으면 자동 저장
      if (!currentId && (titleEl.value.trim() || getContent().trim())) { await createNote(); return; }
      if (currentId) { await saveNote(); }
    }, 1200);
    async function deleteNote() {
      if (!currentId) { statusEl.textContent = "삭제할 노트가 없습니다."; return; }
      if (!confirm("정말 이 노트를 삭제할까요?")) return;
      await fetch(`${API}/notes/${currentId}`, { method:"DELETE" });
      currentId = null; setEditor(null); statusEl.textContent = "삭제 완료";
      await fetchList();
    }

    // ===== 어시스턴트 =====
    function renderChat(){
      chatLogEl.innerHTML = chatHistory.map(m =>
        `<div class="msg ${m.role==='user'?'me':'bot'}"><div class="bubble">${escapeHtml(m.text)}</div></div>`
      ).join("");
      chatLogEl.scrollTop = chatLogEl.scrollHeight;
    }
    async function sendChat(){
      const text = chatInputEl.value.trim(); if(!text) return;
      chatInputEl.value = ""; chatHistory.push({role:"user", text}); renderChat();
      try {
        const res = await fetch(`${API}/chat`, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify({ message:text, history:chatHistory }) });
        const data = await res.json();
        chatHistory.push({ role:"assistant", text: data.reply || "(응답 없음)" });
      } catch {
        chatHistory.push({ role:"assistant", text: "연결 오류: 서버 확인 필요" });
      }
      renderChat();
    }

    // ===== 이벤트 =====
    searchBtn.onclick = fetchList;
    newBtn.onclick = createNote;
    delBtn.onclick = deleteNote;
    saveBtn.onclick = saveNote;

    sendBtn.onclick = sendChat;
    clearChatBtn.onclick = () => { chatHistory=[]; renderChat(); };
    chatInputEl.addEventListener("keydown", e => { if (e.key === "Enter") sendChat(); });

    document.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if ((e.ctrlKey||e.metaKey) && k === "s") { e.preventDefault(); saveNote(); }
      if ((e.ctrlKey||e.metaKey) && k === "n") { e.preventDefault(); createNote(); }
    });

    // ===== Electron IPC (있으면 실시간 리스트 갱신) & 백업 폴링 =====
    if (window.electronAPI?.onNotesChanged) {
      window.electronAPI.onNotesChanged(async () => {
        await fetchList();
        if (currentId && !notes.find(n => n.id === currentId)) { currentId = null; setEditor(null); }
      });
    }
    setInterval(() => { fetchList().catch(()=>{}); }, 30000);

    // ===== 초기 로딩 =====
    (async function init(){
      initEditor();               // 먼저 에디터 생성
      await fetchList();
      if (notes[0]) await loadNote(notes[0].id);
      renderChat();
    })();
  </script>
</body>
</html>
