<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Local Notes — Main</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- 스타일 -->
  <style>
    :root{ --bg:#fafafa; --line:#e5e5e5; --left:280px; --right:360px; }
    *{ box-sizing:border-box } html,body{ height:100%; margin:0; }
    body{ font-family:system-ui, Segoe UI, Apple SD Gothic Neo, Malgun Gothic, sans-serif; background:var(--bg); }
    .layout{ display:grid; grid-template-columns: var(--left) 1fr var(--right); gap:10px; height:100vh; padding:10px; }
    .panel{ background:#fff; border:1px solid var(--line); border-radius:12px; padding:12px; overflow:auto; }
    .split-col{ display:flex; flex-direction:column; gap:10px; height:100% }
    .list{ display:flex; flex-direction:column; gap:6px; }
    .note-item{ padding:8px; border:1px solid transparent; border-radius:8px; cursor:pointer; }
    .note-item:hover{ background:#f7f7f7; } .note-item.active{ background:#eef2ff; border-color:#c7d2fe; }
    .muted{ color:#666; font-size:12px }
    .tag{ background:#efefef; border-radius:999px; padding:2px 8px; font-size:12px; margin-right:6px }
    input[type=text]{ width:100%; padding:10px; border:1px solid var(--line); border-radius:8px; }
    .row{ display:flex; gap:8px; align-items:center }
    .btn{ padding:8px 10px; border:1px solid var(--line); border-radius:8px; background:#f5f5f5; cursor:pointer }
    .primary{ background:#111; color:#fff; border-color:#111 }
    .editor{ display:flex; flex-direction:column; gap:10px; height:100% }
    /* Toast UI Editor 높이 보정 */
    #mdEditor{ flex:1; min-height:420px; }
    .toastui-editor-defaultUI{ height:100%; }
    .toastui-editor-main{ height:calc(100% - 44px); } /* toolbar 제외 */
    .toastui-editor-contents{ font-size:15px; line-height:1.6; }
    /* 분석 결과 리스트 */
    #analysisGoals ul{ margin:6px 0 0 18px; padding:0; }
    #analysisGoals li{ margin:2px 0; }
  </style>

  <!-- Toast UI Editor (CDN) -->
  <link rel="stylesheet" href="https://uicdn.toast.com/editor/latest/toastui-editor.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script>
  <script src="https://uicdn.toast.com/editor/latest/toastui-editor-all.min.js"></script>

  <!-- Mermaid (마인드맵 렌더) -->
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script> mermaid.initialize({ startOnLoad:false, theme:'default' }); </script>
</head>
<body>
  <div class="layout">
    <!-- 왼쪽: 노트 리스트 -->
    <aside class="panel split-col">
      <div>
        <h2 style="margin:0 0 8px 0;">노트</h2>
        <div class="row">
          <input id="q" type="text" placeholder="검색 (제목/본문)" />
          <button class="btn" id="searchBtn">검색</button>
        </div>
        <div class="row" style="margin-top:8px;">
          <button class="btn primary" id="newBtn">새 노트</button>
          <button class="btn" id="delBtn">삭제</button>
        </div>
      </div>
      <div class="list" id="noteList"></div>
    </aside>

    <!-- 가운데: 편집기 -->
    <main class="panel editor">
      <div class="row" style="gap:6px;">
        <input id="title" type="text" placeholder="제목" style="flex:1;" />
        <!-- ✅ AI 분석 버튼 추가 -->
        <button class="btn" id="analyzeBtn">AI 분석</button>
        <button class="btn primary" id="saveBtn">저장</button>
      </div>
      <input id="tags" type="text" placeholder="태그: 쉼표로 구분" />
      <!-- WYSIWYG 마크다운 에디터 -->
      <div id="mdEditor"></div>
      <div class="muted" id="status">대기 중</div>
    </main>

    <!-- 오른쪽: 어시스턴트 + 분석 결과 영역 추가 -->
    <aside class="panel">
      <h2 style="margin:0 0 8px 0;">어시스턴트</h2>

      <!-- ✅ AI 분석 결과 영역 -->
      <div style="margin-bottom:10px;">
        <h3 style="margin:0 0 6px 0;">AI 분석 결과</h3>
        <div id="analysisSummary" class="muted" style="margin-bottom:6px;"></div>
        <div id="analysisGoals" style="font-size:14px; line-height:1.5;"></div>

        <!-- ✅ 마인드맵 래퍼 + 툴바 -->
        <div id="mindmapWrap" style="position:relative; border:1px solid var(--line); border-radius:8px; height:420px; overflow:hidden;">
          <div class="mm-toolbar" style="position:absolute; right:8px; top:8px; display:flex; gap:6px; z-index:2;">
            <button id="mmZoomIn"  class="btn" title="확대">＋</button>
            <button id="mmZoomOut" class="btn" title="축소">－</button>
            <button id="mmReset"   class="btn" title="리셋">⟳</button>
            <button id="mmFit"     class="btn" title="맞춤">▣</button>
            <button id="mmSaveSVG" class="btn" title="SVG 저장">SVG</button>
            <button id="mmSavePNG" class="btn" title="PNG 저장">PNG</button>
          </div>
          <div id="mindmap" style="width:100%; height:100%;"></div>
        </div>
      </div>

      <div id="chatLog" style="border:1px solid var(--line); border-radius:8px; padding:8px; height:38%; overflow:auto"></div>
      <div class="row" style="margin-top:8px;">
        <input id="chatInput" type="text" placeholder="질문을 입력하세요…" style="flex:1;" />
        <button class="btn primary" id="sendBtn">보내기</button>
        <button class="btn" id="clearChat">지우기</button>
      </div>
    </aside>
  </div>

  <!-- ===== 스크립트 ===== -->
  <script>
    const API = "http://127.0.0.1:8421/api";
    const $ = s => document.querySelector(s);

    // DOM
    const noteListEl = $("#noteList");
    const qEl = $("#q"), searchBtn = $("#searchBtn");
    const newBtn = $("#newBtn"), delBtn = $("#delBtn");
    const titleEl = $("#title"), tagsEl = $("#tags"), saveBtn = $("#saveBtn"), statusEl = $("#status");
    const analyzeBtn = $("#analyzeBtn");                        // ✅
    const analysisSummaryEl = $("#analysisSummary");            // ✅
    const analysisGoalsEl   = $("#analysisGoals");              // ✅
    const mindmapEl         = $("#mindmap");                    // ✅
    const chatLogEl = $("#chatLog"), chatInputEl = $("#chatInput"),
          sendBtn = $("#sendBtn"), clearChatBtn = $("#clearChat");

    // 상태
    let currentId = null;
    let notes = [];
    let chatHistory = [];
    let editor = null; // Toast UI Editor 인스턴스
    let mmPan = null;

    const escapeHtml = s => (s ?? "").replace(/[&<>"']/g, m => ({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"}[m]));
    const debounce = (fn, ms=500) => { let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; };

    // ===== 에디터 =====
    function initEditor() {
      editor = new toastui.Editor({
        el: document.querySelector('#mdEditor'),
        height: '100%',
        initialEditType: 'markdown',   // 편집과 렌더를 한 화면에서
        previewStyle: 'tab',
        usageStatistics: false,
        placeholder: '여기에 마크다운을 입력하세요…',
        toolbarItems: [
          ['heading','bold','italic','strike'],
          ['hr','quote'],
          ['ul','ol','task'],
          ['table','link','image','code','codeblock'],
        ]
      });
      editor.on('change', () => { statusEl.textContent = '편집 중…'; autoSave(); });
    }
    function getContent(){ return editor ? editor.getMarkdown() : ''; }
    function setContent(v){ if (editor) editor.setMarkdown(v || ''); }

    // ===== 리스트 =====
    function renderList() {
      noteListEl.innerHTML = "";
      if (!Array.isArray(notes) || notes.length === 0) {
        noteListEl.innerHTML = `<div class="muted">노트가 없습니다.</div>`;
        return;
      }
      for (const n of notes) {
        const div = document.createElement("div");
        div.className = "note-item" + (n.id === currentId ? " active" : "");
        const when = new Date(n.updated_at).toLocaleString();
        div.innerHTML = `
          <div><strong>${escapeHtml(n.title)}</strong></div>
          <div class="muted" style="font-size:12px">${when}</div>
          <div>${(n.tags||[]).slice(0,3).map(t=>`<span class="tag">${escapeHtml(t)}</span>`).join("")}</div>`;
        div.onclick = () => loadNote(n.id);
        noteListEl.appendChild(div);
      }
    }
    async function fetchList() {
      const url = qEl.value.trim() ? `${API}/notes?query=${encodeURIComponent(qEl.value)}` : `${API}/notes`;
      const res = await fetch(url);
      if (!res.ok) { console.error('GET /api/notes 실패', res.status); return; }
      notes = await res.json(); renderList();
    }

    // ===== 편집/로드/저장 =====
    function setEditor(n) {
      currentId = n?.id || null;
      titleEl.value = n?.title || "";
      tagsEl.value = (n?.tags || []).join(", ");
      setContent(n?.content || "");
      statusEl.textContent = currentId ? `편집 중: ${currentId}` : "새 노트 작성";
      renderList();
    }
    async function loadNote(id) {
      const res = await fetch(`${API}/notes/${id}`);
      if (!res.ok) return;
      setEditor(await res.json());
    }
    async function createNote() {
      const res = await fetch(`${API}/notes`, {
        method:"POST", headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ title:"새 노트", content:"", tags:[] })
      });
      if (!res.ok) return;
      const n = await res.json();
      await fetchList(); await loadNote(n.id);
    }
    async function saveNote() {
      const body = {
        title: titleEl.value.trim(),
        content: getContent(), // 마크다운으로 저장
        tags: tagsEl.value.split(",").map(s=>s.trim()).filter(Boolean)
      };
      if (!body.title) { statusEl.textContent = "제목을 입력해주세요."; return; }
      let res;
      if (!currentId) {
        res = await fetch(`${API}/notes`, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(body) });
        if (!res.ok) return;
        currentId = (await res.json()).id;
        statusEl.textContent = "새 노트 저장 완료";
      } else {
        res = await fetch(`${API}/notes/${currentId}`, { method:"PUT", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(body) });
        if (!res.ok) return;
        statusEl.textContent = "저장 완료";
      }
      await fetchList();
    }
    const autoSave = debounce(async ()=>{
      if (!currentId && (titleEl.value.trim() || getContent().trim())) { await createNote(); return; }
      if (currentId) { await saveNote(); }
    }, 1200);
    async function deleteNote() {
      if (!currentId) { statusEl.textContent = "삭제할 노트가 없습니다."; return; }
      if (!confirm("정말 이 노트를 삭제할까요?")) return;
      await fetch(`${API}/notes/${currentId}`, { method:"DELETE" });
      currentId = null; setEditor(null); statusEl.textContent = "삭제 완료";
      await fetchList();
    }

    // ===== AI 분석 렌더링 =====
    function renderAnalysis(result){
    // 요약/목표 영역 먼저 렌더
    analysisSummaryEl.textContent = result.summary || '';
    if (Array.isArray(result.goals) && result.goals.length) {
      const html = result.goals.map(g => {
        const tasks = (g.tasks||[]).map(t => `<li>✅ ${escapeHtml(t.title||'')}</li>`).join("");
        return `
          <div style="margin:8px 0;">
            <div><strong>🎯 ${escapeHtml(g.title||'')}</strong></div>
            ${g.rationale ? `<div class="muted">${escapeHtml(g.rationale)}</div>` : ""}
            <ul style="margin:6px 0 0 18px">${tasks}</ul>
          </div>`;
      }).join("");
      analysisGoalsEl.innerHTML = html;
    } else {
      analysisGoalsEl.innerHTML = '<div class="muted">제안된 목표가 없습니다.</div>';
    }

    // Mermaid mindmap (한 번만 렌더)
    mindmapEl.innerHTML = '';
    const code = result.mermaid || 'graph TD\nROOT[Empty]';
    const id = 'mm' + Math.random().toString(36).slice(2);

    mermaid.render(id, code).then(({ svg }) => {
      mindmapEl.innerHTML = svg;

      // pan/zoom 적용
      const svgEl = mindmapEl.querySelector('svg');
      if (!svgEl) return;

      if (mmPan) { try { mmPan.destroy(); } catch(e){} }

      mmPan = svgPanZoom(svgEl, {
        zoomEnabled: true,
        panEnabled: true,
        controlIconsEnabled: false,
        fit: true,
        center: true,
        minZoom: 0.2,
        maxZoom: 10,             // ← 충분히 크게
        zoomScaleSensitivity: 0.2
      });
      if (mmPan.enableMouseWheelZoom) mmPan.enableMouseWheelZoom();

      // 초기 맞춤
      mmPan.resize();
      mmPan.fit();
      mmPan.center();
    }).catch(err => {
      console.error('mermaid render error', err);
      mindmapEl.textContent = '마인드맵 렌더 오류';
    });
  }

    document.getElementById('mmZoomIn').onclick  = () => mmPan && mmPan.zoomBy(1.2);
    document.getElementById('mmZoomOut').onclick = () => mmPan && mmPan.zoomBy(0.8);
    document.getElementById('mmReset').onclick   = () => {
      if (!mmPan) return;
      mmPan.zoom(1); mmPan.center();
    };
    document.getElementById('mmFit').onclick     = () => {
      if (!mmPan) return;
      mmPan.resize(); mmPan.fit(); mmPan.center();
    };

    // ✅ 창 리사이즈 시 자동 맞춤
    window.addEventListener('resize', () => {
      if (!mmPan) return;
      mmPan.resize(); mmPan.fit(); mmPan.center();
    });

    const ipcRenderer = (window.require && window.require('electron'))
      ? window.require('electron').ipcRenderer
      : null;

    //현재 화면의 Mermaid SVG를 문자열로 가져오기
    function getMindmapSVGString() {
      const svg = document.querySelector('#mindmap svg');
      if (!svg) return null;

      let { width, height } = svg.getBoundingClientRect();
      const vb = svg.getAttribute('viewBox');
      if ((!svg.getAttribute('width') || !svg.getAttribute('height')) && vb) {
        const parts = vb.split(/\s+/).map(Number);
        if (parts.length === 4) {
          width = parts[2];
          height = parts[3];
        }
      }
      const clone = svg.cloneNode(true);
      clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      if (width && height) {
        clone.setAttribute('width', String(Math.round(width)));
        clone.setAttribute('height', String(Math.round(height)));
      }
      const xml = new XMLSerializer().serializeToString(clone);
      return `<?xml version="1.0" encoding="UTF-8"?>\n${xml}`;
    }

    //Anchor 다운로드 플백
    function downloadBlobinPage(blob, filename = 'mindmap') {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    //SVG 저장
    async function exportMindmapSVG() {
      const svgString = getMindmapSVGString();
      if (!svgString) { alert('저장할 마인드맵이 없습니다.'); return;}
      const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8'});

      if (ipcRenderer) {
        const base64 = btoa(unescape(encodeURIComponent(svgString)));
        const res = await ipcRenderer.invoke('save-file', {
          dataBase64 : base64,
          defaultPath : 'mindmap.svg',
          mime : 'image/svg+xml'
        });
        if (!res?.ok) alert('저장 취소 또는 실패');
      } else {
        downloadBlobinPage(blob, 'mindmap.svg');
      }
    }

    //PNG 저장 (canvas로 래스터화; scale로 해상도 선택)
    async function exportMindmapPNG(scale = 2) {
      const svgString = getMindmapSVGString();
      if (!svgString) { alert('저장할 마이든맵이 없습니다.'); return;}
      
      // data ULR -> load image
      const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8'});
      const url = URL.createObjectURL(svgBlob);
      const img = new Image();
      img.onload = async () => {
        const svg = document.querySelector('#mindmap svg');
        let w = img.width, h = img.height;
        if (svg) {
          const vb = svg.getAttribute('viewBox');
          if (vb) {
            const parts = vb.split(/\s+/).map(Number);
            if(parts.length === 4) {
              w = parts[2];
              h = parts[3];
            }
          }
        }
        w = Math.max(1, Math.round(img.width * scale));
        h = Math.max(1, Math.round(img.height * scale));
        const canvas = document.createElement('canvas');
        canvas.width = w; canvas.height = h;
        const ctx = canvas.getContext('2d');
        ctx.setTransform(scale, 0, 0, scale, 0, 0);
        ctx.drawImage(img, 0, 0);
        URL.revokeObjectURL(url);

        canvas.toBlob(async (blob) => {
          if (!blob) { alert('PNG 변환 실패'); return; }
          if (ipcRenderer) {
            const buf = await blob.arrayBuffer();
            // ArrayBuffer → base64
            let binary = '';
            const bytes = new Uint8Array(buf);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) binary += String.fromCharCode(bytes[i]);
            const base64 = btoa(binary);
            const res = await ipcRenderer.invoke('save-bytes', {
              dataBase64: base64,
              defaultPath: 'mindmap.png',
              mime: 'image/png'
            });
            if (!res?.ok) alert('저장 취소 또는 실패');
          } else {
            downloadBlobinPage(blob, 'mindmap.png');
          }
        }, 'image/png', 1.0);
      };
      img.onerror = () => { URL.revokeObjectURL(url); alert('SVG 이미지를 불러오지 못했습니다.'); };
      img.src = url;
    }

    document.getElementById('mmSaveSVG').onclick = () => exportMindmapSVG();
    document.getElementById('mmSavePNG').onclick = async () => {
      const svgString = getMindmapSVGString();
      if (!svgString) return alert('저장할 마인드맵이 없습니다.');

      const res = await window.api.saveSvgAsPng({
        svgString,
        defaultPath: 'mindmap.png',
        scale: 4, // 1=원본, 2~4로 올리면 고해상도
      });
      if (!res?.ok) alert('저장 취소 또는 실패');
    };


    // ===== 어시스턴트 =====
    function renderChat(){
      chatLogEl.innerHTML = chatHistory.map(m =>
        `<div class="msg ${m.role==='user'?'me':'bot'}"><div class="bubble">${escapeHtml(m.text)}</div></div>`
      ).join("");
      chatLogEl.scrollTop = chatLogEl.scrollHeight;
    }
    async function sendChat(){
      const text = chatInputEl.value.trim(); if(!text) return;
      chatInputEl.value = ""; chatHistory.push({role:"user", text}); renderChat();
      try {
        const res = await fetch(`${API}/chat`, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify({ message:text, history:chatHistory }) });
        const data = await res.json();
        chatHistory.push({ role:"assistant", text: data.reply || "(응답 없음)" });
      } catch {
        chatHistory.push({ role:"assistant", text: "연결 오류: 서버 확인 필요" });
      }
      renderChat();
    }

    // ===== 이벤트 =====
    searchBtn.onclick = fetchList;
    newBtn.onclick = createNote;
    delBtn.onclick = deleteNote;
    saveBtn.onclick = saveNote;

    // ✅ AI 분석 버튼 동작
    analyzeBtn.onclick = async () => {
      const title = titleEl.value.trim() || 'Untitled';
      const content = getContent();
      if (!content.trim()) { statusEl.textContent = '분석할 내용이 없습니다.'; return; }
      analyzeBtn.disabled = true; analyzeBtn.textContent = '분석 중…';
      try {
        const res = await fetch(`${API}/analyze`, {
          method:'POST',
          headers:{ 'Content-Type':'application/json' },
          body: JSON.stringify({ title, content })
        });
        const text = await res.text();
        let data = null;
        try { data = JSON.parse(text); } catch {}
        if (!res.ok) {
          console.error('analyze 실패', res.status, text);
          statusEl.textContent = `분석 실패(${res.status})`;
          if (data) renderAnalysis(data);
          return;
        }
        if (!data) { statusEl.textContent = '분석 실패 (빈 응답)'; return;}
        renderAnalysis(data);
        statusEl.textContent = '분석 완료';
      } catch(e){
        console.error(e);
        statusEl.textContent = '분석 실패 (네트워크)';
      } finally {
        analyzeBtn.disabled = false; analyzeBtn.textContent = 'AI 분석';
      }
    };

    sendBtn.onclick = sendChat;
    clearChatBtn.onclick = () => { chatHistory=[]; renderChat(); };
    chatInputEl.addEventListener("keydown", e => { if (e.key === "Enter") sendChat(); });

    document.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if ((e.ctrlKey||e.metaKey) && k === "s") { e.preventDefault(); saveNote(); }
      if ((e.ctrlKey||e.metaKey) && k === "n") { e.preventDefault(); createNote(); }
    });

    // ===== Electron IPC & 폴링 =====
    if (window.electronAPI?.onNotesChanged) {
      window.electronAPI.onNotesChanged(async () => {
        await fetchList();
        if (currentId && !notes.find(n => n.id === currentId)) { currentId = null; setEditor(null); }
      });
    }
    setInterval(() => { fetchList().catch(()=>{}); }, 30000);

    // ===== 초기 로딩 =====
    (async function init(){
      initEditor();
      await fetchList();
      if (notes[0]) await loadNote(notes[0].id);
      renderChat();
    })();
  </script>
</body>
</html>
